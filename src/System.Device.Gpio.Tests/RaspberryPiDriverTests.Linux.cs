// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Device.Gpio.Drivers;
using System.Diagnostics;
using System.Threading;
using Xunit;

namespace System.Device.Gpio.Tests
{
    [Trait("requirement", "root")]
    [Trait("feature", "gpio")]
    [Trait("feature", "gpio-rpi3")]
    public class RaspberryPiDriverTests : GpioControllerTestBase
    {
        /// <summary>
        /// Leave this pin open (unconnected) for the tests
        /// </summary>
        private const int OpenPin = 23;

        protected override GpioDriver GetTestDriver() => new RaspberryPi3Driver();

        protected override PinNumberingScheme GetTestNumberingScheme() => PinNumberingScheme.Logical;

        /// <summary>
        /// Tests for setting the pull up/pull down resistors on the Raspberry Pi (supported on Pi3 and Pi4, but with different techniques)
        /// </summary>
        [Fact]
        public void InputPullResistorsWork()
        {
            using (GpioController controller = new GpioController(GetTestNumberingScheme(), GetTestDriver()))
            {
                controller.OpenPin(OpenPin, PinMode.InputPullUp);
                Assert.Equal(PinValue.High, controller.Read(OpenPin));

                for (int i = 0; i < 100; i++)
                {
                    controller.SetPinMode(OpenPin, PinMode.InputPullDown);
                    Assert.Equal(PinValue.Low, controller.Read(OpenPin));

                    controller.SetPinMode(OpenPin, PinMode.InputPullUp);
                    Assert.Equal(PinValue.High, controller.Read(OpenPin));
                }

                // change one more time so that when running test in a loop we start with the inverted option
                controller.SetPinMode(OpenPin, PinMode.InputPullDown);
                Assert.Equal(PinValue.Low, controller.Read(OpenPin));
            }
        }

        [Fact]
        public void FastInterruptHandling()
        {
            const int numPulses = 100;
            // These are in ms
            const int pulseLength = 1;
            const int waitTime = 20;

            // int maxWaitSpins = 5000;
            int numInterrupts = 0;
            int numRisingEdges = 0;
            using (GpioController controller = new GpioController(GetTestNumberingScheme(), GetTestDriver()))
            {
                controller.OpenPin(InputPin, PinMode.Input);
                controller.OpenPin(OutputPin, PinMode.Output);
                controller.Write(OutputPin, PinValue.Low);
                while (controller.Read(InputPin) == PinValue.High)
                {
                }

                controller.RegisterCallbackForPinValueChangedEvent(InputPin, PinEventTypes.Rising, Callback);
                Stopwatch w = Stopwatch.StartNew();
                // Ensure the poll thread is ready before we continue the actual loop
                // If the triggers are generated by external hardware (which is what the interrupt triggering
                // is for), we don't know when the pulses start, so no synchronisation possible there anyway
                Thread.Sleep(10);
                for (int i = 0; i < numPulses; i++)
                {
                    controller.Write(OutputPin, PinValue.High);
                    Thread.Sleep(TimeSpan.FromMilliseconds(pulseLength));
                    controller.Write(OutputPin, PinValue.Low);
                    Thread.Sleep(TimeSpan.FromMilliseconds(waitTime));
                }

                Thread.Sleep(10);
                controller.UnregisterCallbackForPinValueChangedEvent(InputPin, Callback);
                // All pulses must be marked as rising edge
                Assert.Equal(numInterrupts, numRisingEdges);
                Assert.True(numInterrupts >= numPulses - 1, $"Expected at least {numPulses - 1}, got only {numInterrupts}"); // Allow one missing pulse
                double maxMillis = numPulses * pulseLength * waitTime * 1.7; // That's how long this test should last (at most)
                Assert.True(w.Elapsed < TimeSpan.FromMilliseconds(maxMillis), $"Used {w.Elapsed.TotalMilliseconds}ms, expected max {maxMillis}ms");
            }

            void Callback(object sender, PinValueChangedEventArgs pinValueChangedEventArgs)
            {
                numInterrupts++;
                // Console.WriteLine($"Seen pulse {numInterrupts}");
                Assert.Equal(InputPin, pinValueChangedEventArgs.PinNumber);
                if (pinValueChangedEventArgs.ChangeType == PinEventTypes.Rising)
                {
                    numRisingEdges++;
                }
            }
        }
    }
}
