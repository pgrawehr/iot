// <autogenerated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Device.Gpio;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

#pragma warning disable CS1591
namespace Iot.Device.Arduino
{
    public class CallbackEventArgs
    {
        public CallbackEventArgs(byte port, ushort value)
        {

        }
    }

    public class SysexCallbackEventArgs
    {
        public SysexCallbackEventArgs(
            SysexCommand command_,
            Stream sysex_string_
        )
        {
        }
    }

    public class I2cCallbackEventArgs
    {
        public I2cCallbackEventArgs(byte data0, byte data1, Stream args)
        {

        }
    }

    public enum Command : byte
    {
        DIGITAL_MESSAGE = 144, // 0x00000090
        REPORT_ANALOG_PIN = 192, // 0x000000C0
        REPORT_DIGITAL_PIN = 208, // 0x000000D0
        ANALOG_MESSAGE = 224, // 0x000000E0
        START_SYSEX = 240, // 0x000000F0
        SET_PIN_MODE = 244, // 0x000000F4
        SET_DIGITAL_VALUE = 0xF5,
        END_SYSEX = 247, // 0x000000F7
        PROTOCOL_VERSION = 249, // 0x000000F9
        SYSTEM_RESET = 255 // 0x000000FF
    }

    public enum SysexCommand
    {
        ENCODER_DATA = 0x61,
        SERVO_CONFIG = 0x70,
        STRING_DATA = 0x71,
        STEPPER_DATA = 0x72,
        ONEWIRE_DATA = 0x73,
        SHIFT_DATA = 0x75,
        I2C_REQUEST = 0x76,
        I2C_REPLY = 0x77,
        I2C_CONFIG = 0x78,
        EXTENDED_ANALOG = 0x6F,
        PIN_STATE_QUERY = 0x6D,
        PIN_STATE_RESPONSE = 0x6E,
        CAPABILITY_QUERY = 0x6B,
        CAPABILITY_RESPONSE = 0x6C,
        ANALOG_MAPPING_QUERY = 0x69,
        ANALOG_MAPPING_RESPONSE = 0x6A,
        REPORT_FIRMWARE = 0x79,
        SAMPLING_INTERVAL = 0x7A,
        SCHEDULER_DATA = 0x7B,
        SYSEX_NON_REALTIME = 0x7E,
        SYSEX_REALTIME = 0x7F
    }

    public enum SupportedMode
    {
        DIGITAL_INPUT   =   (0x00),
        DIGITAL_OUTPUT  =   (0x01),
        ANALOG_INPUT    =   (0x02),
        PWM             =   (0x03),
        SERVO           =   (0x04),
        SHIFT           =   (0x05),
        I2C             =   (0x06),
        ONEWIRE         =   (0x07),
        STEPPER         =   (0x08),
        ENCODER         =   (0x09),
        SERIAL          =   (0x0A),
        INPUT_PULLUP    =   (0x0B)
    }

    public delegate void CallbackFunction(UwpFirmata caller, CallbackEventArgs argv);

    public delegate void DigitalPinValueChanged(int pin, PinValue newValue);

    public delegate void StringCallbackFunction(UwpFirmata caller, string data);

    public delegate void SysexCallbackFunction(UwpFirmata caller, SysexCallbackEventArgs args);

    public delegate void I2cReplyCallbackFunction(UwpFirmata caller, I2cCallbackEventArgs args);

    public sealed class UwpFirmata : IDisposable
    {
        private const byte FIRMATA_PROTOCOL_MAJOR_VERSION = 2;
        private const byte FIRMATA_PROTOCOL_MINOR_VERSION = 6;
        private const int FIRMATA_INIT_TIMEOUT_SECONDS = 10;
        private const ulong DATA_BUFFER_SIZE = 31;
        private const int MESSAGE_TIMEOUT_MILLIS = 500;
        private byte _firmwareVersionMajor;
        private byte _firmwareVersionMinor;
        private byte _actualFirmataProtocolMajorVersion;
        private byte _actualFirmataProtocolMinorVersion;

        private string _firmwareName;
        
        private short[] _data_buffer;
        private FirmataStream _firmataStream;
        private bool _connectionReady;
        private Thread _inputThread;
        private bool _inputThreadShouldExit;
        private List<SupportedPinConfiguration> _supportedPinConfigurations;
        private IList<byte> _lastResponse;
        private List<PinValue> _lastPinValues;
        private object _lastPinValueLock;
        private object _synchronisationLock;

        // Event used when waiting for answers (i.e. after requesting firmware version)
        private AutoResetEvent _dataReceived;

        public event DigitalPinValueChanged DigitalPortValueUpdated;

        public event CallbackFunction AnalogValueUpdated;

        public event StringCallbackFunction StringMessageReceived;

        public event I2cReplyCallbackFunction I2cReplyReceived;

        public event Action FirmataConnectionReady;

        public event StringCallbackFunction FirmataConnectionFailed;

        public event StringCallbackFunction FirmataConnectionLost;

        public UwpFirmata()
        {
            _firmwareVersionMajor = 0;
            _firmwareVersionMinor = 0;
            _data_buffer = new short[(int)DATA_BUFFER_SIZE];
            _firmataStream = null;
            _connectionReady = false;
            _inputThreadShouldExit = false;
            _dataReceived = new AutoResetEvent(false);
            _supportedPinConfigurations = new List<SupportedPinConfiguration>();
            _synchronisationLock = new object();
            _lastPinValues = new List<PinValue>();
            _lastPinValueLock = new object();
        }

        internal List<SupportedPinConfiguration> PinConfigurations
        {
            get
            {
                return _supportedPinConfigurations;
            }
        }

        public void begin(FirmataStream s_)
        {
            _firmataStream = s_;

            if (_firmataStream.CanRead && _firmataStream.CanWrite)
            {
                onConnectionEstablished();
            }
            else
            {
                throw new NotSupportedException("Need a read-write stream to the hardware device");
            }

            startListening();
        }

        public bool connectionReady()
        {
            return _connectionReady;
        }

        public void finish()
        {
            stopThreads();
            _connectionReady = false;
            _firmataStream = null;
            _data_buffer = null;
            if (_firmataStream != null)
            {
                _firmataStream.Close();
            }

            _firmataStream = null;
            if (_dataReceived != null)
            {
                _dataReceived.Dispose();
                _dataReceived = null;
            }
        }

        public void sendAnalog(byte pin_, ushort value)
        {
            _firmataStream.Write((byte)(pin_ & 15 | 224));
            _firmataStream.Write((byte)(value & (uint)sbyte.MaxValue));
            _firmataStream.Write((byte)(value >> 7 & sbyte.MaxValue));
            _firmataStream.Flush();
        }

        public void sendDigitalPort(byte port_number_, byte port_data_)
        {
            _firmataStream.Write((byte)(port_number_ & 15 | 144));
            _firmataStream.Write((byte)(port_data_ & (uint)sbyte.MaxValue));
            _firmataStream.Write((byte)((uint)port_data_ >> 7));
            _firmataStream.Flush();
        }

        public void sendString(byte command_, string string_)
        {
            byte[] bytes = Encoding.Unicode.GetBytes(string_);
            _firmataStream.Write(240);
            _firmataStream.Write((byte)(command_ & (uint)sbyte.MaxValue));
            for (ulong index = 0; index < (ulong)bytes.Length; ++index)
                sendValueAsTwo7bitBytes(bytes[(int)index]);
            _firmataStream.Write(247);
            _firmataStream.Flush();
        }

        private void sendString(string string_)
        {
            sendString(113, string_);
        }

        private void sendValueAsTwo7bitBytes(ushort value_)
        {
            _firmataStream.Write((byte)(value_ & (uint)sbyte.MaxValue));
            _firmataStream.Write((byte)(value_ >> 7 & sbyte.MaxValue));
        }

        private void startListening()
        {
            if (_inputThread != null && _inputThread.IsAlive)
            {
                return;
            }

            _inputThreadShouldExit = false;
            UwpFirmata uwpFirmata = this;
            
            uwpFirmata._inputThread = new Thread(inputThread);
            uwpFirmata._inputThread.Start();
        }

        private string createStringFromMbs(byte[] mbs_, int len_)
        {
            return Encoding.Unicode.GetString(mbs_);
        }

        private string createStringFromMbs(byte[] mbs_, int offset, int len_)
        {
            return Encoding.Unicode.GetString(mbs_, offset, mbs_.Length - offset);
        }

        private void processInput()
        {
            // ReadByte reads one byte, but takes an int as an argument, so it can specify -1 for end-of-stream or timeout
            int data = _firmataStream.ReadByte();
            if (data == (0xFFFF))
                return;

            byte b = (byte)(data & 0x00FF);
            byte upper_nibble = (byte)(data & 0xF0);
            byte lower_nibble = (byte)(data & 0x0F);

            /*
             * the relevant bits in the command depends on the value of the data byte. If it is less than 0xF0 (start sysex), only the upper nibble identifies the command
             * while the lower nibble contains additional data
             */
            Command command = (Command)((data < ((ushort)Command.START_SYSEX) ? upper_nibble : b));

            //determine the number of bytes remaining in the message
            int bytes_remaining = 0;
            bool isMessageSysex = false;
            switch (command)
            {
                default: //command not understood
                case Command.END_SYSEX: //should never happen
                    return;

                //commands that require 2 additional bytes
                case Command.DIGITAL_MESSAGE:
                case Command.ANALOG_MESSAGE:
                case Command.SET_PIN_MODE:
                case Command.PROTOCOL_VERSION:
                    bytes_remaining = 2;
                    break;

                //commands that require 1 additional byte
                case Command.REPORT_ANALOG_PIN:
                case Command.REPORT_DIGITAL_PIN:
                    bytes_remaining = 1;
                    break;

                //commands that do not require additional bytes
                case Command.SYSTEM_RESET:
                    //do nothing, as there is nothing to reset
                    return;

                case Command.START_SYSEX:
                    //this is a special case with no set number of bytes remaining
                    isMessageSysex = true;
                    break;
            }

            //read the remaining message while keeping track of elapsed time to timeout in case of incomplete message
            List<byte> message = new List<byte>();
            int bytes_read = 0;
            Stopwatch timeout_start = Stopwatch.StartNew();
            while (bytes_remaining > 0 || isMessageSysex)
            {
                data = _firmataStream.ReadByte();

                //if no data was available, check for timeout
                if (data == 0xFFFF)
                {
                    //get elapsed seconds, given as a double with resolution in nanoseconds
                    var elapsed = timeout_start.Elapsed;

                    if (elapsed.TotalMilliseconds > MESSAGE_TIMEOUT_MILLIS)
                    {
                        return;
                    }

                    continue;
                }

                timeout_start.Restart();

                //if we're parsing sysex and we've just read the END_SYSEX command, we're done.
                if (isMessageSysex && (data == (short)Command.END_SYSEX))
                    break;

                message.Add((byte)(data & 0xFF));
                ++bytes_read;
                --bytes_remaining;
            }

            //process the message
            switch (command)
            {
                //ignore these message types
                default:
                case Command.REPORT_ANALOG_PIN:
                case Command.REPORT_DIGITAL_PIN:
                case Command.SET_PIN_MODE:
                case Command.END_SYSEX:
                case Command.SYSTEM_RESET:
                    return;
                case Command.PROTOCOL_VERSION:
                    _actualFirmataProtocolMajorVersion = message[0];
                    _actualFirmataProtocolMinorVersion = message[1];
                    _dataReceived.Set();

                    return;

                case Command.ANALOG_MESSAGE:
                    //report analog commands store the pin number in the lower nibble of the command byte, the value is split over two 7-bit bytes
                    AnalogValueUpdated(this,
                        new CallbackEventArgs(lower_nibble, (ushort)(message[0] | (message[1] << 7))));
                    break;

                case Command.DIGITAL_MESSAGE:
                    // digital messages store the port number in the lower nibble of the command byte, the port value is split over two 7-bit bytes
                    // Each port corresponds to 8 pins
                {
                    int offset = lower_nibble * 8;
                    ushort pinValues = (ushort)(message[0] | (message[1] << 7));
                    lock (_lastPinValueLock)
                    {
                        for (int i = 0; i < 8; i++)
                        {
                            PinValue oldValue = _lastPinValues[i + offset];
                            int mask = 1 << i;
                            PinValue newValue = (pinValues & mask) == 0 ? PinValue.Low : PinValue.High;
                            if (newValue != oldValue)
                            {
                                _lastPinValues[i + offset] = newValue;
                                DigitalPortValueUpdated?.Invoke(i + offset, newValue);
                            }
                        }
                    }
                }
                    break;

                case Command.START_SYSEX:
                    //a sysex message must include at least one extended-command byte
                    if (bytes_read < 1)
                        return;

                    //retrieve the raw data array & extract the extended-command byte
                    var raw_data = message.ToArray();
                    SysexCommand sysCommand = (SysexCommand)(raw_data[0]);
                    int index = 0;
                    ++index;
                    --bytes_read;

                    MemoryStream writer = new MemoryStream();
                    switch (sysCommand)
                    {
                        case SysexCommand.REPORT_FIRMWARE:
                            // See https://github.com/firmata/protocol/blob/master/protocol.md
                            // Byte 0 is the command (0x79) and can be skipped here, as we've already interpreted it
                            
                            _firmwareVersionMajor = raw_data[1];
                            _firmwareVersionMinor = raw_data[2];
                            _firmwareName = createStringFromMbs(raw_data, 3, message.Count - 3);
                            _dataReceived.Set();
                            

                            return;

                        case SysexCommand.STRING_DATA:

                            //condense back into 1-byte data
                            reassembleByteString(raw_data, bytes_read);

                            StringMessageReceived(this, createStringFromMbs(raw_data, bytes_read / 2));

                            break;

                        case SysexCommand.CAPABILITY_RESPONSE:

                            {
                                _supportedPinConfigurations.Clear();
                                int idx = 1;
                                var currentPin = new SupportedPinConfiguration(0);
                                int pin = 0;
                                while (idx < raw_data.Length)
                                {
                                    int mode = raw_data[idx++];
                                    if (mode == 0x7F)
                                    {
                                        _supportedPinConfigurations.Add(currentPin);
                                        currentPin = new SupportedPinConfiguration(++pin);
                                        continue;
                                    }

                                    int resolution = raw_data[idx++];
                                    switch ((SupportedMode)mode)
                                    {
                                        case SupportedMode.DIGITAL_INPUT:
                                            currentPin.PinModes.Add(PinMode.Input);
                                            break;
                                        case SupportedMode.DIGITAL_OUTPUT:
                                            currentPin.PinModes.Add(PinMode.Output);
                                            break;
                                        case SupportedMode.INPUT_PULLUP:
                                            currentPin.PinModes.Add(PinMode.InputPullUp);
                                            break;
                                        case SupportedMode.ANALOG_INPUT:
                                            currentPin.AnalogInputResolutionBits = resolution;
                                            break;

                                    }
                                }

                                // Add 8 entries, so that later we do not need to check whether a port (bank) is complete
                                _lastPinValues = new PinValue[_supportedPinConfigurations.Count + 8].ToList();
                                _dataReceived.Set();
                                // Do not add the last instance, should also be terminated by 0xF7
                            }

                            break;

                        case SysexCommand.I2C_REPLY:

                            //condense back into 1-byte data
                            reassembleByteString(raw_data, bytes_read);

                            //if we're receiving an I2C reply, the first two bytes in our reply are the address and register
                            for (int i = 2; i < bytes_read / 2; ++i)
                            {
                                writer.WriteByte(raw_data[i]);
                            }

                            I2cReplyReceived(this, new I2cCallbackEventArgs(raw_data[0], raw_data[1], writer));
                            break;

                        case SysexCommand.PIN_STATE_RESPONSE:
                            _lastResponse = raw_data; // the instance is constant, so we can just remember the pointer
                            _dataReceived.Set();
                            break;

                        default:

                            // we pass the data forward as-is for any other type of sysex command
                            break;
                    }

                    break;
            }

            //this library does not support digital write, but we need to consume the rest of the message
        }

        private void inputThread()
        {
            while (!_inputThreadShouldExit)
            {
                try
                {
                    processInput();
                }
                catch (Exception ex)
                {
                    onConnectionLost(ex.Message);
                }
            }
        }

        public Version QueryFirmataVersion()
        {
            lock (_synchronisationLock)
            {
                _dataReceived.Reset();
                _firmataStream.Write((byte)Command.PROTOCOL_VERSION);
                _firmataStream.Flush();
                bool result = _dataReceived.WaitOne(TimeSpan.FromSeconds(FIRMATA_INIT_TIMEOUT_SECONDS));
                if (result == false)
                {
                    throw new TimeoutException("Timeout waiting for firmata version");
                }

                return new Version(_actualFirmataProtocolMajorVersion, _actualFirmataProtocolMinorVersion);
            }
        }

        public Version QuerySupportedFirmataVersion()
        {
            return new Version(FIRMATA_PROTOCOL_MAJOR_VERSION, FIRMATA_PROTOCOL_MINOR_VERSION);
        }

        public Version QueryFirmwareVersion(out string firmwareName)
        {
            lock (_synchronisationLock)
            {
                _dataReceived.Reset();
                _firmataStream.Write((byte)Command.START_SYSEX);
                _firmataStream.Write((byte)SysexCommand.REPORT_FIRMWARE);
                _firmataStream.Write((byte)Command.END_SYSEX);
                bool result = _dataReceived.WaitOne(TimeSpan.FromSeconds(FIRMATA_INIT_TIMEOUT_SECONDS));
                if (result == false)
                {
                    throw new TimeoutException("Timeout waiting for firmata version");
                }

                firmwareName = _firmwareName;
                return new Version(_firmwareVersionMajor, _firmwareVersionMinor);
            }
        }

        public void QueryCapabilities()
        {
            lock (_synchronisationLock)
            {
                _dataReceived.Reset();
                _firmataStream.Write((byte)Command.START_SYSEX);
                _firmataStream.Write((byte)SysexCommand.CAPABILITY_QUERY);
                _firmataStream.Write((byte)Command.END_SYSEX);
                bool result = _dataReceived.WaitOne(TimeSpan.FromSeconds(FIRMATA_INIT_TIMEOUT_SECONDS));
                if (result == false)
                {
                    throw new TimeoutException("Timeout waiting for device capabilities");
                }
            }
        }

        private void onConnectionEstablished()
        {
            _connectionReady = true;
            FirmataConnectionReady?.Invoke();
        }

        private void onConnectionFailed(string message_)
        {
            FirmataConnectionFailed?.Invoke(this, message_);
        }

        private void onConnectionLost(string message_)
        {
            _connectionReady = false;
            FirmataConnectionLost?.Invoke(this, message_);
        }

        private void stopThreads()
        {
            _inputThreadShouldExit = true;
            _inputThread.Join();
            _inputThreadShouldExit = false;
        }

        public void SetPinMode(int pin, PinMode mode)
        {
            SupportedMode firmataMode;
            switch (mode)
            {
                case PinMode.Output:
                    firmataMode = SupportedMode.DIGITAL_OUTPUT;
                    break;
                case PinMode.InputPullUp:
                    firmataMode = SupportedMode.INPUT_PULLUP;
                    break;
                case PinMode.Input:
                    firmataMode = SupportedMode.DIGITAL_INPUT;
                    break;
                default: 
                    throw new NotSupportedException($"Mode {mode} is not supported for this operation");
            }

            lock (_synchronisationLock)
            {
                _firmataStream.WriteByte((byte)Command.SET_PIN_MODE);
                _firmataStream.WriteByte((byte)pin);
                _firmataStream.WriteByte((byte)firmataMode);
                _firmataStream.Flush();
            }
        }

        public PinMode GetPinMode(int pinNumber)
        {
            lock (_synchronisationLock)
            {
                _dataReceived.Reset();
                _firmataStream.WriteByte((byte)Command.START_SYSEX);
                _firmataStream.WriteByte((byte)SysexCommand.PIN_STATE_QUERY);
                _firmataStream.WriteByte((byte)pinNumber);
                _firmataStream.WriteByte((byte)Command.END_SYSEX);
                _firmataStream.Flush();
                bool result = _dataReceived.WaitOne(TimeSpan.FromSeconds(FIRMATA_INIT_TIMEOUT_SECONDS));
                if (result == false)
                {
                    throw new TimeoutException("Timeout waiting for pin mode.");
                }

                // The mode is byte 4
                if (_lastResponse.Count < 4)
                {
                    throw new InvalidOperationException("Not enough data in reply");
                }

                if (_lastResponse[1] != pinNumber)
                {
                    throw new InvalidOperationException(
                        "The reply didn't match the query (another port was indicated)");
                }

                SupportedMode mode = (SupportedMode)(_lastResponse[2]);
                switch (mode)
                {
                    case SupportedMode.DIGITAL_OUTPUT:
                        return PinMode.Output;
                    case SupportedMode.INPUT_PULLUP:
                        return PinMode.InputPullUp;
                    case SupportedMode.DIGITAL_INPUT:
                        return PinMode.Input;
                    default:
                        return PinMode.Input; // TODO: Return "Unknown"
                }
            }
        }

        /// <summary>
        /// Enables digital pin reporting for all ports (one port has 8 pins)
        /// </summary>
        public void EnableDigitalReporting()
        {
            int numPorts = (int)Math.Ceiling(PinConfigurations.Count / 8.0);
            for (byte i = 0; i < numPorts; i++)
            {
                _firmataStream.WriteByte((byte)(0xD0 + i));
                _firmataStream.WriteByte(1);
                _firmataStream.Flush();
            }
        }

        public PinValue GetDigitalPinState(int pinNumber)
        {
            lock (_lastPinValueLock)
            {
                return _lastPinValues[pinNumber];
            }
        }

        public void WriteDigitalPin(int pin, PinValue value)
        {
            lock (_synchronisationLock)
            {
                _firmataStream.WriteByte((byte)Command.SET_DIGITAL_VALUE);
                _firmataStream.WriteByte((byte)pin);
                _firmataStream.WriteByte((byte)(value == PinValue.High ? 1 : 0));
                _firmataStream.Flush();
            }
        }

        private void reassembleByteString(byte[] byte_string_, int length_)
        {
            int num;
            for (num = 0; num < length_ / 2; ++num)
            {
                byte_string_[num] = (byte)(byte_string_[(num * 2)] |
                                           byte_string_[(num * 2 + 1)] << 7);
            }

            byte_string_[num] = 0;
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                finish();
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
