// <autogenerated />

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

#pragma warning disable CS1591
namespace Iot.Device.Arduino
{
    public class CallbackEventArgs
    {
        public CallbackEventArgs(byte port, ushort value)
        {

        }
    }

    public class SysexCallbackEventArgs
    { 
        public SysexCallbackEventArgs(
    SysexCommand command_,
    Stream sysex_string_
    )
        { }
    }

    public class I2cCallbackEventArgs
    {
        public I2cCallbackEventArgs(byte data0, byte data1, Stream args)
        {

        }
    } 

    public enum Command
    {
        DIGITAL_MESSAGE = 144, // 0x00000090
        REPORT_ANALOG_PIN = 192, // 0x000000C0
        REPORT_DIGITAL_PIN = 208, // 0x000000D0
        ANALOG_MESSAGE = 224, // 0x000000E0
        START_SYSEX = 240, // 0x000000F0
        SET_PIN_MODE = 244, // 0x000000F4
        END_SYSEX = 247, // 0x000000F7
        PROTOCOL_VERSION = 249, // 0x000000F9
        SYSTEM_RESET = 255 // 0x000000FF
    }

    public enum SysexCommand
    {
        ENCODER_DATA = 0x61,
        SERVO_CONFIG = 0x70,
        STRING_DATA = 0x71,
        STEPPER_DATA = 0x72,
        ONEWIRE_DATA = 0x73,
        SHIFT_DATA = 0x75,
        I2C_REQUEST = 0x76,
        I2C_REPLY = 0x77,
        I2C_CONFIG = 0x78,
        EXTENDED_ANALOG = 0x6F,
        PIN_STATE_QUERY = 0x6D,
        PIN_STATE_RESPONSE = 0x6E,
        CAPABILITY_QUERY = 0x6B,
        CAPABILITY_RESPONSE = 0x6C,
        ANALOG_MAPPING_QUERY = 0x69,
        ANALOG_MAPPING_RESPONSE = 0x6A,
        REPORT_FIRMWARE = 0x79,
        SAMPLING_INTERVAL = 0x7A,
        SCHEDULER_DATA = 0x7B,
        SYSEX_NON_REALTIME = 0x7E,
        SYSEX_REALTIME = 0x7F
    }

    public delegate void CallbackFunction(UwpFirmata caller, CallbackEventArgs argv);

    public delegate void StringCallbackFunction(UwpFirmata caller, string data);

    public delegate void SysexCallbackFunction(UwpFirmata caller, SysexCallbackEventArgs args);

    public delegate void I2cReplyCallbackFunction(UwpFirmata caller, I2cCallbackEventArgs args);
    public sealed class UwpFirmata : IDisposable
    {
        private byte FIRMATA_PROTOCOL_MAJOR_VERSION;
        private byte FIRMATA_PROTOCOL_MINOR_VERSION;
        private double MESSAGE_TIMEOUT_MILLIS;
        private byte firmwareVersionMajor;
        private byte firmwareVersionMinor;
        private string firmwareName;
        private ulong DATA_BUFFER_SIZE;
        private short[] _data_buffer;
        private FirmataStream _firmata_stream;
        private bool _connection_ready;
        private object _firmata_lock;
        private Thread _input_thread;
        private bool _input_thread_should_exit;

        public event CallbackFunction DigitalPortValueUpdated;

        public event CallbackFunction AnalogValueUpdated;

        public event StringCallbackFunction StringMessageReceived;

        public event SysexCallbackFunction SysexMessageReceived;

        public event SysexCallbackFunction PinCapabilityResponseReceived;

        public event I2cReplyCallbackFunction I2cReplyReceived;

        public event CallbackFunction SystemResetRequested;

        public event Action FirmataConnectionReady;

        public event StringCallbackFunction FirmataConnectionFailed;

        public event StringCallbackFunction FirmataConnectionLost;

        public UwpFirmata()
        {
            FIRMATA_PROTOCOL_MAJOR_VERSION = 2;
            FIRMATA_PROTOCOL_MINOR_VERSION = 3;
            MESSAGE_TIMEOUT_MILLIS = 500.0;
            firmwareVersionMajor = 0;
            firmwareVersionMinor = 0;
            DATA_BUFFER_SIZE = 31UL;
            UwpFirmata uwpFirmata = this;
            uwpFirmata._data_buffer = new short[(int)uwpFirmata.DATA_BUFFER_SIZE];
            _firmata_stream = null;
            _connection_ready = false;
            _firmata_lock = new object();
            _input_thread_should_exit = false;
        }

        ~UwpFirmata()
        {
            finish();
        }

        public void begin(FirmataStream s_)
        {
            _firmata_stream = s_;

            if (_firmata_stream.CanRead && _firmata_stream.CanWrite)
            {
                onConnectionEstablished();
            }
            else
            {
                throw new NotSupportedException("Need a read-write stream to the hardware device");
            }

            //we always care about the connection being lost
            // _firmata_stream.ConnectionLost += ref new Microsoft::Maker::Serial::IStreamConnectionCallbackWithMessage(this, &Microsoft::Maker::Firmata::UwpFirmata::onConnectionLost);
        }

        public bool connectionReady()
        {
            return _connection_ready;
        }

        public void finish()
        {
            Monitor.Enter(_firmata_lock);
            stopThreads();
            _connection_ready = false;
            _firmata_stream = null;
            _data_buffer = null;
            if (_firmata_stream != null)
            {
                _firmata_stream.flush();
                _firmata_stream.end();
            }
            _firmata_stream = null;
            Monitor.Exit(_firmata_lock);
        }

        public void flush()
        {
            _firmata_stream.flush();
        }

        public void printFirmwareVersion()
        {
            if (firmwareName == null)
                return;
            _firmata_stream.write(240);
            _firmata_stream.write(121);
            _firmata_stream.write(firmwareVersionMajor);
            _firmata_stream.write(firmwareVersionMinor);
            for (ulong index = 0; index < (ulong)firmwareName.Length; ++index)
            {
                UwpFirmata uwpFirmata = this;
                uwpFirmata.sendValueAsTwo7bitBytes((ushort)uwpFirmata.firmwareName.IndexOf((char)index));
            }
            _firmata_stream.write(247);
            _firmata_stream.flush();
        }

        public void printVersion()
        {
            _firmata_stream.write(249);
            _firmata_stream.write(FIRMATA_PROTOCOL_MAJOR_VERSION);
            _firmata_stream.write(FIRMATA_PROTOCOL_MINOR_VERSION);
            _firmata_stream.flush();
        }

    public void sendAnalog(byte pin_, ushort value)
    {
      _firmata_stream.write((byte) (pin_ & 15 | 224));
      _firmata_stream.write((byte) (value & (uint) sbyte.MaxValue));
      _firmata_stream.write((byte) (value >> 7 & sbyte.MaxValue));
      _firmata_stream.flush();
    }

    public void sendDigitalPort(byte port_number_, byte port_data_)
    {
      _firmata_stream.write((byte) (port_number_ & 15 | 144));
      _firmata_stream.write((byte) (port_data_ & (uint) sbyte.MaxValue));
      _firmata_stream.write((byte) ((uint) port_data_ >> 7));
      _firmata_stream.flush();
    }

    public void sendString(byte command_, string string_)
    {
      byte[] bytes = Encoding.Unicode.GetBytes(string_);
      _firmata_stream.write(240);
      _firmata_stream.write((byte) (command_ & (uint) sbyte.MaxValue));
      for (ulong index = 0; index < (ulong) bytes.Length; ++index)
        sendValueAsTwo7bitBytes(bytes[(int) index]);
      _firmata_stream.write(247);
      _firmata_stream.flush();
    }

    public void sendString(string string_)
    {
      sendString(113, string_);
    }

    public void sendValueAsTwo7bitBytes(ushort value_)
    {
      _firmata_stream.write((byte) (value_ & (uint) sbyte.MaxValue));
      _firmata_stream.write((byte) (value_ >> 7 & sbyte.MaxValue));
    }

    public void setFirmwareNameAndVersion(string name_, byte major_, byte minor_)
    {
      firmwareName = name_;
      firmwareVersionMajor = major_;
      firmwareVersionMinor = minor_;
    }

    public void startListening()
    {
      if (_input_thread.IsAlive)
        return;
      _input_thread_should_exit = false;
      UwpFirmata uwpFirmata = this;
      // ISSUE: method pointer
      uwpFirmata._input_thread = new Thread(inputThread);
      uwpFirmata._input_thread.Start();
    }

    public void write(byte c_)
    {
      _firmata_stream.write(c_);
    }

    private string createStringFromMbs(byte[] mbs_, int len_)
    {
      return Encoding.Unicode.GetString(mbs_);
    }

        void processInput()
        {
            ushort data = _firmata_stream.read();
            if (data == (0xFFFF))
                return;

            byte b = (byte)(data & 0x00FF);
            byte upper_nibble = (byte)(data & 0xF0);
            byte lower_nibble = (byte)(data & 0x0F);

            /*
             * the relevant bits in the command depends on the value of the data byte. If it is less than 0xF0 (start sysex), only the upper nibble identifies the command
             * while the lower nibble contains additional data
             */
            Command command = (Command)((data < ((ushort)Command.START_SYSEX) ? upper_nibble : b));

            //determine the number of bytes remaining in the message
            int bytes_remaining = 0;
            bool isMessageSysex = false;
            switch (command)
            {
                default: //command not understood
                case Command.END_SYSEX: //should never happen
                    return;

                //commands that require 2 additional bytes
                case Command.DIGITAL_MESSAGE:
                case Command.ANALOG_MESSAGE:
                case Command.SET_PIN_MODE:
                case Command.PROTOCOL_VERSION:
                    bytes_remaining = 2;
                    break;

                //commands that require 1 additional byte
                case Command.REPORT_ANALOG_PIN:
                case Command.REPORT_DIGITAL_PIN:
                    bytes_remaining = 1;
                    break;

                //commands that do not require additional bytes
                case Command.SYSTEM_RESET:
                    //do nothing, as there is nothing to reset
                    return;

                case Command.START_SYSEX:
                    //this is a special case with no set number of bytes remaining
                    isMessageSysex = true;
                    break;
            }

            //read the remaining message while keeping track of elapsed time to timeout in case of incomplete message
            List<byte> message = new List<byte>();
            int bytes_read = 0;
            Stopwatch timeout_start = Stopwatch.StartNew();
            while (bytes_remaining > 0 || isMessageSysex)
            {
                data = _firmata_stream.read();

                //if no data was available, check for timeout
                if (data == 0xFFFF)
                {
                    //get elapsed seconds, given as a double with resolution in nanoseconds
                    var elapsed = timeout_start.Elapsed;

                    if (elapsed.TotalMilliseconds > MESSAGE_TIMEOUT_MILLIS)
                    {
                        return;
                    }

                    continue;
                }

                timeout_start.Restart();

                //if we're parsing sysex and we've just read the END_SYSEX command, we're done.
                if (isMessageSysex && (data == (short)Command.END_SYSEX))
                    break;

                message.Add((byte)(data & 0xFF));
                ++bytes_read;
                --bytes_remaining;
            }

            //process the message
            switch (command)
            {
                //ignore these message types
                default:
                case Command.REPORT_ANALOG_PIN:
                case Command.REPORT_DIGITAL_PIN:
                case Command.SET_PIN_MODE:
                case Command.END_SYSEX:
                case Command.SYSTEM_RESET:
                case Command.PROTOCOL_VERSION:
                    return;

                case Command.ANALOG_MESSAGE:
                    //report analog commands store the pin number in the lower nibble of the command byte, the value is split over two 7-bit bytes
                    AnalogValueUpdated(this, new CallbackEventArgs(lower_nibble, (ushort)(message[0] | (message[1] << 7))));
                    break;

                case Command.DIGITAL_MESSAGE:
                    //digital messages store the port number in the lower nibble of the command byte, the port value is split over two 7-bit bytes
                    DigitalPortValueUpdated(this, new CallbackEventArgs(lower_nibble, (ushort)(message[0] | (message[1] << 7))));
                    break;

                case Command.START_SYSEX:
                    //a sysex message must include at least one extended-command byte
                    if (bytes_read < 1)
                        return;

                    //retrieve the raw data array & extract the extended-command byte
                    var raw_data = message.ToArray();
                    SysexCommand sysCommand = (SysexCommand)(raw_data[0]);
                    int index = 0;
                    ++index;
                    --bytes_read;

                    MemoryStream writer = new MemoryStream();
                    switch (sysCommand)
                    {
                        case SysexCommand.STRING_DATA:

                            //condense back into 1-byte data
                            reassembleByteString(raw_data, bytes_read);

                            StringMessageReceived(this, createStringFromMbs(raw_data, bytes_read / 2));

                            break;

                        case SysexCommand.CAPABILITY_RESPONSE:

                            //Firmata does not handle capability responses in the typical way (separating bytes), so we write them directly to the DataWriter
                            for (int i = 0; i < bytes_read; ++i)
                            {
                                writer.WriteByte(raw_data[i]);
                            }

                            writer.Seek(0, SeekOrigin.Begin);
                            PinCapabilityResponseReceived(this, new SysexCallbackEventArgs(sysCommand, writer));

                            break;

                        case SysexCommand.I2C_REPLY:

                            //condense back into 1-byte data
                            reassembleByteString(raw_data, bytes_read);

                            //if we're receiving an I2C reply, the first two bytes in our reply are the address and register
                            for (int i = 2; i < bytes_read / 2; ++i)
                            {
                                writer.WriteByte(raw_data[i]);
                            }

                            I2cReplyReceived(this, new I2cCallbackEventArgs(raw_data[0], raw_data[1], writer));
                            break;

                        default:

                            // we pass the data forward as-is for any other type of sysex command
                            for (int i = 0; i < bytes_read; ++i)
                            {
                                writer.WriteByte(raw_data[i]);
                            }

                            writer.Seek(0, SeekOrigin.Begin);
                            SysexMessageReceived(this, new SysexCallbackEventArgs(sysCommand, writer));
                            break;
                    }

                    break;
            }

            //this library does not support digital write, but we need to consume the rest of the message
        }

        private void inputThread()
    {
      while (!_input_thread_should_exit)
      {
        try
        {
          processInput();
        }
        catch (Exception ex)
        {
            onConnectionLost(ex.Message);
        }
      }
    }

    private void onConnectionEstablished()
    {
      _connection_ready = true;
      FirmataConnectionReady?.Invoke();
    }

    private void onConnectionFailed(string message_)
    {
      FirmataConnectionFailed?.Invoke(this, message_);
    }

    private void onConnectionLost(string message_)
    {
      _connection_ready = false;
      FirmataConnectionLost?.Invoke(this, message_);
    }

    private void stopThreads()
    {
      _input_thread_should_exit = true;
      _input_thread.Join();
      _input_thread_should_exit = false;
    }

    private void reassembleByteString(byte[] byte_string_, int length_)
    {
      int num;
      for (num = 0; num < length_ / 2; ++num)
      {
          byte_string_[num] = (byte)(byte_string_[(num * 2)] |
                                     byte_string_[(num * 2 + 1)] << 7);
      }

      byte_string_[num] = 0;
    }

    private void Dispose(bool disposing)
    {
        if (disposing)
        {
            finish();
        }
    }

    public void Dispose()
    {
      Dispose(true);
      GC.SuppressFinalize(this);
    }
  }
}
